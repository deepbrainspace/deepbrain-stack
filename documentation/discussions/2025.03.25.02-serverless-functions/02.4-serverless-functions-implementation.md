Date: 2025-03-25
---

# Serverless Functions Implementation Details

This document provides technical implementation details for the serverless functions discussed in our architecture updates.

## 1. Backup Automation Function

### Google Cloud Function (backup-trigger)

```javascript
const { HetznerCloudClient } = require('hetzner-cloud');
const { Firestore } = require('@google-cloud/firestore');

const firestore = new Firestore();
const hetznerClient = new HetznerCloudClient({ token: process.env.HETZNER_API_TOKEN });

/**
 * Triggered by Cloud Scheduler to start the backup process
 * @param {Object} event Cloud Scheduler event
 */
exports.triggerBackup = async (event, context) => {
  // Determine backup type based on date
  const today = new Date();
  const backupTypes = [];
  
  // Daily backup (always run)
  backupTypes.push('daily');
  
  // Weekly backup (run on Sundays)
  if (today.getDay() === 0) {
    backupTypes.push('weekly');
  }
  
  // Monthly backup (run on 1st of month)
  if (today.getDate() === 1) {
    backupTypes.push('monthly');
  }
  
  // Update status in Firestore
  const backupRef = firestore.collection('backups').doc(today.toISOString().split('T')[0]);
  await backupRef.set({
    startTime: Firestore.FieldValue.serverTimestamp(),
    types: backupTypes,
    status: 'starting',
  });
  
  // Create server from snapshot
  try {
    const server = await hetznerClient.servers.create({
      name: `backup-${today.toISOString().split('T')[0]}`,
      server_type: 'cx11', // Smallest server type
      image: process.env.BACKUP_SNAPSHOT_ID,
      networks: [
        { id: process.env.PRIVATE_NETWORK_ID }
      ],
      user_data: Buffer.from(JSON.stringify({
        backupTypes,
        backupDate: today.toISOString(),
        firestoreDocId: backupRef.id,
        r2Bucket: process.env.R2_BUCKET,
        r2AccessKey: process.env.R2_ACCESS_KEY,
        r2SecretKey: process.env.R2_SECRET_KEY,
      })).toString('base64'),
    });
    
    // Update status with server info
    await backupRef.update({
      serverId: server.id,
      serverIp: server.public_net.ipv4.ip,
      status: 'server_created',
    });
    
    console.log(`Backup server created: ${server.id}`);
    return { success: true, serverId: server.id };
  } catch (error) {
    console.error('Error creating backup server:', error);
    
    // Update status with error
    await backupRef.update({
      status: 'error',
      error: error.message,
    });
    
    throw error;
  }
};
```

### Backup Server User Data Script (runs on server startup)

```bash
#!/bin/bash
# This script runs on the backup server at startup

# Parse user data
USER_DATA=$(curl -s http://169.254.169.254/hetzner/v1/metadata/user-data)
BACKUP_TYPES=$(echo $USER_DATA | jq -r '.backupTypes')
BACKUP_DATE=$(echo $USER_DATA | jq -r '.backupDate')
FIRESTORE_DOC_ID=$(echo $USER_DATA | jq -r '.firestoreDocId')
R2_BUCKET=$(echo $USER_DATA | jq -r '.r2Bucket')
R2_ACCESS_KEY=$(echo $USER_DATA | jq -r '.r2AccessKey')
R2_SECRET_KEY=$(echo $USER_DATA | jq -r '.r2SecretKey')

# Update status
update_status() {
  gcloud firestore documents update "backups/$FIRESTORE_DOC_ID" --update-property="status=$1"
}

# Mount SeaweedFS volumes
update_status "mounting_volumes"
mkdir -p /mnt/seaweedfs
mount -t seaweedfs seaweedfs-master:9333 /mnt/seaweedfs

# Configure restic
export RESTIC_REPOSITORY="s3:https://s3.${R2_BUCKET}.cloudflare.r2.com/backups"
export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY"
export AWS_SECRET_ACCESS_KEY="$R2_SECRET_KEY"

# Run backups for each type
for TYPE in $BACKUP_TYPES; do
  update_status "backing_up_$TYPE"
  
  # Set retention policy based on type
  case $TYPE in
    daily)
      KEEP_POLICY="--keep-daily 7"
      ;;
    weekly)
      KEEP_POLICY="--keep-weekly 4"
      ;;
    monthly)
      KEEP_POLICY="--keep-monthly 12"
      ;;
  esac
  
  # Run backup
  restic backup /mnt/seaweedfs --tag $TYPE --tag $BACKUP_DATE
  
  # Apply retention policy
  restic forget --prune $KEEP_POLICY --tag $TYPE
  
  # Check backup
  restic check
done

# Update status
update_status "completed"

# Self-destruct after 5 minutes (allow time for status updates)
(sleep 300 && curl -X DELETE -H "Authorization: Bearer $HETZNER_API_TOKEN" \
  https://api.hetzner.cloud/v1/servers/$(curl -s http://169.254.169.254/hetzner/v1/metadata/id)) &

exit 0
```

## 2. API Integration Functions

### Cloudflare Worker for Aircall Webhook

```javascript
// Aircall Webhook Worker

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
  // Only accept POST requests
  if (request.method !== 'POST') {
    return new Response('Method Not Allowed', { status: 405 })
  }
  
  // Verify webhook signature
  const signature = request.headers.get('X-Aircall-Signature')
  if (!await verifySignature(request, signature)) {
    return new Response('Invalid Signature', { status: 401 })
  }
  
  // Parse webhook data
  const data = await request.json()
  
  // Transform data to our standard format
  const transformedData = transformAircallData(data)
  
  // Store in Firestore
  const firestoreResponse = await storeInFirestore(transformedData)
  
  return new Response(JSON.stringify({ success: true }), {
    headers: { 'Content-Type': 'application/json' }
  })
}

async function verifySignature(request, signature) {
  // Implementation of signature verification
  // ...
  return true
}

function transformAircallData(data) {
  // Transform Aircall data to our standard format
  const eventType = data.event
  const timestamp = new Date().toISOString()
  
  // Different transformations based on event type
  switch (eventType) {
    case 'call.created':
      return {
        type: 'call',
        action: 'created',
        timestamp,
        source: 'aircall',
        sourceId: data.call.id,
        data: {
          callId: data.call.id,
          direction: data.call.direction,
          status: data.call.status,
          startedAt: data.call.started_at,
          answeredAt: data.call.answered_at,
          endedAt: data.call.ended_at,
          duration: data.call.duration,
          phoneNumber: data.call.number.name,
          user: data.call.user ? {
            id: data.call.user.id,
            name: data.call.user.name,
            email: data.call.user.email
          } : null,
          contact: data.call.contact ? {
            id: data.call.contact.id,
            name: data.call.contact.name,
            phoneNumber: data.call.contact.phone_number
          } : null
        }
      }
    // Add other event types as needed
    default:
      return {
        type: 'unknown',
        action: eventType,
        timestamp,
        source: 'aircall',
        sourceId: data.id || 'unknown',
        data: data
      }
  }
}

async function storeInFirestore(data) {
  // Store data in Firestore
  const url = 'https://firestore.googleapis.com/v1/projects/your-project-id/databases/(default)/documents/aircall-events'
  
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${await getFirebaseToken()}`
    },
    body: JSON.stringify({
      fields: convertToFirestoreFields(data)
    })
  })
  
  return response.json()
}

async function getFirebaseToken() {
  // Get Firebase token from Cloudflare Workers KV or other secure storage
  return SECRETS.get('FIREBASE_TOKEN')
}

function convertToFirestoreFields(data) {
  // Convert JavaScript object to Firestore fields format
  // ...
}
```

### Google Cloud Function for Vectorization

```javascript
const { Firestore } = require('@google-cloud/firestore');
const { QdrantClient } = require('@qdrant/js-client-rest');

const firestore = new Firestore();
const qdrant = new QdrantClient({ 
  url: process.env.QDRANT_URL,
  apiKey: process.env.QDRANT_API_KEY
});

/**
 * Triggered by Firestore document creation in the aircall-events collection
 */
exports.vectorizeAircallEvent = async (event, context) => {
  // Get the document data
  const documentData = event.value.fields;
  const documentName = context.resource.name;
  const documentId = documentName.split('/').pop();
  
  // Convert Firestore fields to regular object
  const data = convertFromFirestoreFields(documentData);
  
  // Create text representation for vectorization
  const textRepresentation = createTextRepresentation(data);
  
  // Get vector embedding from text
  const vector = await getVectorEmbedding(textRepresentation);
  
  // Store in Qdrant
  await qdrant.upsert('business-data', {
    points: [{
      id: `aircall-${data.sourceId}`,
      vector: vector,
      payload: {
        source: 'aircall',
        type: data.type,
        action: data.action,
        timestamp: data.timestamp,
        text: textRepresentation,
        data: data.data
      }
    }]
  });
  
  // Update Firestore document with vectorization status
  await firestore.doc(`aircall-events/${documentId}`).update({
    vectorized: true,
    vectorizedAt: Firestore.FieldValue.serverTimestamp()
  });
  
  console.log(`Vectorized Aircall event: ${documentId}`);
  return { success: true };
};

function convertFromFirestoreFields(fields) {
  // Convert Firestore fields format to JavaScript object
  // ...
}

function createTextRepresentation(data) {
  // Create a text representation of the data for vectorization
  let text = '';
  
  switch (data.type) {
    case 'call':
      text = `Call ${data.action} on ${new Date(data.timestamp).toLocaleString()}. `;
      
      if (data.data.direction) {
        text += `Direction: ${data.data.direction}. `;
      }
      
      if (data.data.status) {
        text += `Status: ${data.data.status}. `;
      }
      
      if (data.data.duration) {
        text += `Duration: ${data.data.duration} seconds. `;
      }
      
      if (data.data.user && data.data.user.name) {
        text += `Agent: ${data.data.user.name}. `;
      }
      
      if (data.data.contact && data.data.contact.name) {
        text += `Contact: ${data.data.contact.name}. `;
      }
      
      if (data.data.phoneNumber) {
        text += `Phone number: ${data.data.phoneNumber}. `;
      }
      
      break;
    // Add other types as needed
    default:
      text = `${data.type} ${data.action} on ${new Date(data.timestamp).toLocaleString()}.`;
  }
  
  return text;
}

async function getVectorEmbedding(text) {
  // Get vector embedding from text using an embedding API
  const response = await fetch('https://api.groq.com/openai/v1/embeddings', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.GROQ_API_KEY}`
    },
    body: JSON.stringify({
      model: 'embedding-001',
      input: text
    })
  });
  
  const result = await response.json();
  return result.data[0].embedding;
}
```

## 3. RocketChat Message Vectorization

### MongoDB Change Stream Listener (Docker service)

```javascript
// mongo-listener.js
const { MongoClient } = require('mongodb');
const { PubSub } = require('@google-cloud/pubsub');

// Configuration
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://mongodb:27017/rocketchat';
const PUBSUB_PROJECT_ID = process.env.PUBSUB_PROJECT_ID;
const PUBSUB_TOPIC = process.env.PUBSUB_TOPIC || 'rocketchat-messages';

// Clients
const mongoClient = new MongoClient(MONGODB_URI);
const pubSubClient = new PubSub({ projectId: PUBSUB_PROJECT_ID });
const topic = pubSubClient.topic(PUBSUB_TOPIC);

async function main() {
  try {
    // Connect to MongoDB
    await mongoClient.connect();
    console.log('Connected to MongoDB');
    
    const db = mongoClient.db();
    const messagesCollection = db.collection('rocketchat_message');
    
    // Create change stream
    const changeStream = messagesCollection.watch([
      { $match: { operationType: { $in: ['insert', 'update'] } } }
    ]);
    
    console.log('Watching for new messages...');
    
    // Listen for changes
    changeStream.on('change', async (change) => {
      if (change.operationType === 'insert') {
        const message = change.fullDocument;
        
        // Only process text messages
        if (message.t || !message.msg) {
          return;
        }
        
        console.log(`New message: ${message._id}`);
        
        // Prepare message data
        const messageData = {
          id: message._id,
          roomId: message.rid,
          userId: message.u._id,
          username: message.u.username,
          text: message.msg,
          timestamp: message.ts ? new Date(message.ts.$date).toISOString() : new Date().toISOString(),
          mentions: message.mentions || [],
          channels: message.channels || []
        };
        
        // Publish to Pub/Sub
        try {
          const dataBuffer = Buffer.from(JSON.stringify(messageData));
          const messageId = await topic.publish(dataBuffer);
          console.log(`Message ${message._id} published to Pub/Sub with ID: ${messageId}`);
        } catch (error) {
          console.error('Error publishing to Pub/Sub:', error);
        }
      }
    });
    
    // Error handling
    changeStream.on('error', (error) => {
      console.error('Change stream error:', error);
      // Attempt to reconnect
      setTimeout(main, 5000);
    });
    
    // Handle graceful shutdown
    process.on('SIGINT', async () => {
      console.log('Closing connections...');
      await changeStream.close();
      await mongoClient.close();
      process.exit(0);
    });
    
  } catch (error) {
    console.error('Error in main function:', error);
    // Attempt to reconnect
    setTimeout(main, 5000);
  }
}

// Start the application
main();
```

### Google Cloud Function for Message Vectorization

```javascript
const { QdrantClient } = require('@qdrant/js-client-rest');
const { Firestore } = require('@google-cloud/firestore');

const qdrant = new QdrantClient({ 
  url: process.env.QDRANT_URL,
  apiKey: process.env.QDRANT_API_KEY
});
const firestore = new Firestore();

/**
 * Triggered from a message on a Pub/Sub topic.
 *
 * @param {object} message The Pub/Sub message.
 * @param {object} context The event metadata.
 */
exports.vectorizeMessage = async (message, context) => {
  // Parse the message data
  const messageData = JSON.parse(Buffer.from(message.data, 'base64').toString());
  console.log(`Processing message: ${messageData.id}`);
  
  // Store message in Firestore
  await firestore.collection('rocketchat-messages').doc(messageData.id).set({
    ...messageData,
    vectorized: false,
    processedAt: Firestore.FieldValue.serverTimestamp()
  });
  
  // Get vector embedding
  const vector = await getVectorEmbedding(messageData.text);
  
  // Store in Qdrant
  await qdrant.upsert('chat-messages', {
    points: [{
      id: `message-${messageData.id}`,
      vector: vector,
      payload: {
        source: 'rocketchat',
        type: 'message',
        id: messageData.id,
        roomId: messageData.roomId,
        userId: messageData.userId,
        username: messageData.username,
        text: messageData.text,
        timestamp: messageData.timestamp
      }
    }]
  });
  
  // Update Firestore document
  await firestore.collection('rocketchat-messages').doc(messageData.id).update({
    vectorized: true,
    vectorizedAt: Firestore.FieldValue.serverTimestamp()
  });
  
  console.log(`Vectorized message: ${messageData.id}`);
  return { success: true };
};

async function getVectorEmbedding(text) {
  // Get vector embedding from text using an embedding API
  const response = await fetch('https://api.groq.com/openai/v1/embeddings', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.GROQ_API_KEY}`
    },
    body: JSON.stringify({
      model: 'embedding-001',
      input: text
    })
  });
  
  const result = await response.json();
  return result.data[0].embedding;
}
```

## 4. LLM Query Processing

### Cloudflare Worker for LLM Queries

```javascript
// LLM Query Worker

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
  // Only accept POST requests
  if (request.method !== 'POST') {
    return new Response('Method Not Allowed', { status: 405 })
  }
  
  // Verify webhook signature from RocketChat
  const signature = request.headers.get('X-RocketChat-Signature')
  if (!await verifySignature(request, signature)) {
    return new Response('Invalid Signature', { status: 401 })
  }
  
  // Parse webhook data
  const data = await request.json()
  
  // Check if this is a message that needs LLM processing
  if (!shouldProcessMessage(data)) {
    return new Response(JSON.stringify({ success: true, processed: false }), {
      headers: { 'Content-Type': 'application/json' }
    })
  }
  
  // Extract the query from the message
  const query = extractQuery(data)
  
  // Get relevant context from Qdrant
  const context = await getRelevantContext(query)
  
  // Get LLM response from Groq
  const llmResponse = await getLLMResponse(query, context)
  
  // Send response back to RocketChat
  await sendResponseToRocketChat(data, llmResponse)
  
  // Store the interaction in Firestore
  await storeInteraction(data, query, context, llmResponse)
  
  return new Response(JSON.stringify({ success: true, processed: true }), {
    headers: { 'Content-Type': 'application/json' }
  })
}

async function verifySignature(request, signature) {
  // Implementation of signature verification
  // ...
  return true
}

function shouldProcessMessage(data) {
  // Check if this message should be processed by the LLM
  // For example, it might be a direct message to a bot user
  // or it might contain a specific trigger phrase
  
  // Check if it's a direct message to the bot
  if (data.message.mentions && data.message.mentions.some(m => m.username === 'assistant')) {
    return true
  }
  
  // Check if it contains a trigger phrase
  const triggerPhrases = ['@assistant', '!query', '?']
  return triggerPhrases.some(phrase => data.message.msg.includes(phrase))
}

function extractQuery(data) {
  // Extract the actual query from the message
  let query = data.message.msg
  
  // Remove trigger phrases
  query = query.replace(/@assistant/g, '').trim()
  query = query.replace(/!query/g, '').trim()
  
  return query
}

async function getRelevantContext(query) {
  // Get vector embedding for the query
  const vector = await getVectorEmbedding(query)
  
  // Search Qdrant for relevant context
  const qdrantUrl = `${QDRANT_URL}/collections/business-data/points/search`
  const searchResponse = await fetch(qdrantUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'API-Key': QDRANT_API_KEY
    },
    body: JSON.stringify({
      vector: vector,
      limit: 5,
      with_payload: true
    })
  })
  
  const searchResults = await searchResponse.json()
  
  // Format context from search results
  let context = ''
  if (searchResults.result && searchResults.result.length > 0) {
    context = searchResults.result.map(item => {
      return `${item.payload.text}`
    }).join('\n\n')
  }
  
  return context
}

async function getVectorEmbedding(text) {
  // Get vector embedding from text using an embedding API
  const response = await fetch('https://api.groq.com/openai/v1/embeddings', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${GROQ_API_KEY}`
    },
    body: JSON.stringify({
      model: 'embedding-001',
      input: text
    })
  })
  
  const result = await response.json()
  return result.data[0].embedding
}

async function getLLMResponse(query, context) {
  // Prepare the prompt with context
  const prompt = `You are an assistant for a BnB business. Answer the following question based on the context provided.
  
Context:
${context}

Question: ${query}

Answer:`
  
  // Get response from Groq LLM
  const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${GROQ_API_KEY}`
    },
    body: JSON.stringify({
      model: 'llama3-70b-8192',
      messages: [
        { role: 'system', content: 'You are a helpful assistant for a BnB business.' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.7,
      max_tokens: 1024
    })
  })
  
  const result = await response.json()
  return result.choices[0].message.content
}

async function sendResponseToRocketChat(data, llmResponse) {
  // Send the LLM response back to RocketChat
  const rocketChatUrl = `${ROCKETCHAT_URL}/api/v1/chat.postMessage`
  
  await fetch(rocketChatUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Auth-Token': ROCKETCHAT_TOKEN,
      'X-User-Id': ROCKETCHAT_USER_ID
    },
    body: JSON.stringify({
      roomId: data.message.rid,
      text: llmResponse,
      alias: 'AI Assistant',
      avatar: 'https://your-domain.com/assistant-avatar.png',
      attachments: [{
        color: '#00a5e4',
        text: 'This response was generated by AI based on your business data.'
      }]
    })
  })
}

async function storeInteraction(data, query, context, llmResponse) {
  // Store the interaction in Firestore
  const firestoreUrl = 'https://firestore.googleapis.com/v1/projects/your-project-id/databases/(default)/documents/llm-interactions'
  
  await fetch(firestoreUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${await getFirebaseToken()}`
    },
    body: JSON.stringify({
      fields: {
        messageId: { stringValue: data.message._id },
        roomId: { stringValue: data.message.rid },
        userId: { stringValue: data.message.u._id },
        username: { stringValue: data.message.u.username },
        query: { stringValue: query },
        context: { stringValue: context },
        response: { stringValue: llmResponse },
        timestamp: { timestampValue: new Date().toISOString() }
      }
    })
  })
}

async function getFirebaseToken() {
  // Get Firebase token from Cloudflare Workers KV or other secure storage
  return SECRETS.get('FIREBASE_TOKEN')
}
```

## Docker Compose for MongoDB Listener

```yaml
# docker-compose.mongo-listener.yml
version: '3.8'

services:
  mongo-listener:
    image: node:16-alpine
    restart: unless-stopped
    working_dir: /app
    volumes:
      - ./mongo-listener:/app
    environment:
      - MONGODB_URI=mongodb://mongodb:27017/rocketchat
      - PUBSUB_PROJECT_ID=${PUBSUB_PROJECT_ID}
      - PUBSUB_TOPIC=rocketchat-messages
      - GOOGLE_APPLICATION_CREDENTIALS=/app/credentials/service-account.json
    command: >
      sh -c "npm install && node mongo-listener.js"
    networks:
      - rocketchat_network

networks:
  rocketchat_network:
    external: true
```